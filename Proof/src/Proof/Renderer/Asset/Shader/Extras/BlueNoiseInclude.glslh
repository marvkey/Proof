//https://github.com/GPUOpen-LibrariesAndSDKs/FidelityFX-SDK/blob/main/sdk/include/FidelityFX/gpu/sssr/ffx_sssr_prepare_blue_noise_texture.h
//https://github.com/qiutang98/flower/blob/0414798840c1c4aef4e742f521696378695e7897/source/shader/common/shared_bluenoise.glsl
#ifndef BLUE_NOISE_INCLUDE_GLSL
#define BLUE_NOISE_INCLUDE_GLSL

const uint kBlueNoiseDim = 128;

#ifdef BLUE_NOISE_BUFFER_BEGIN_BINDING
#extension GL_EXT_samplerless_texture_functions : enable

    #define GOLDEN_RATIO                       1.61803398875f

    layout(set = 1, binding = BLUE_NOISE_BUFFER_BEGIN_BINDING) readonly buffer SobolBuffer { uint s_Sobol_256spp_256d[]; };
    layout(set = 1, binding = BLUE_NOISE_BUFFER_BEGIN_BINDING + 1) readonly buffer RankingTileBuffer { uint s_RankingTile[]; };
    layout(set = 1, binding = BLUE_NOISE_BUFFER_BEGIN_BINDING + 2) readonly buffer ScramblingTileBuffer { uint s_ScramblingTile[]; };
    layout(set = 1, binding = BLUE_NOISE_BUFFER_BEGIN_BINDING + 3) uniform utexture2D u_SobolTextureBuffer;
    layout(set = 1, binding = BLUE_NOISE_BUFFER_BEGIN_BINDING + 4) uniform utexture2D u_ScramblingTileTextureBuffer;
    layout(set = 1, binding = BLUE_NOISE_BUFFER_BEGIN_BINDING + 5) uniform texture2D u_BlueNoiseTexture;
    /*
    float SampleRandomNumber(uint pixel_i, uint pixel_j, uint sampleIndex, uint sampleDimension)
    {
        // wrap arguments
        pixel_i = pixel_i & 127u;
        pixel_j = pixel_j & 127u;
        sampleIndex = sampleIndex & 255u;
        sampleDimension = sampleDimension & 255u;

        // xor index based on optimized ranking
        uint rankedSampleIndex = sampleIndex ^ s_RankingTile[sampleDimension + (pixel_i + pixel_j * 128u) * 8u];

        // fetch value in sequence
        uint value = s_Sobol_256spp_256d[sampleDimension + rankedSampleIndex * 256u];

        // If the dimension is optimized, xor sequence value based on optimized scrambling
        value = value ^ s_ScramblingTile[(sampleDimension%8) + (pixel_i + pixel_j * 128u) * 8u];

        // convert to float and return
        float v = (0.5f + value) / 256.0f;

        return v;
         
    }
    */
   /*   

    vec2 SampleRandomVector2D(uvec2 pixel, uint frameIndex) 
    {
        float u0 = fmod(SampleRandomNumber(pixel.x, pixel.y, 0, 0u) + float(frameIndex & 0xFFu) * GOLDEN_RATIO, 1.0);
        float u1 = fmod(SampleRandomNumber(pixel.x, pixel.y, 0, 1u) + float(frameIndex & 0xFFu) * GOLDEN_RATIO, 1.0);
        return vec2(u0, u1);
    }
    */
    uint GetSobolSample(uvec3 coordinate)
    {
        return uint(texelFetch(u_SobolTextureBuffer, ivec2(coordinate.xy), int(coordinate.z)).r);
    }

    uint GetScramblingTile(uvec3 coordinate) 
    {
        return uint(texelFetch(u_ScramblingTileTextureBuffer, ivec2(coordinate.xy), int(coordinate.z)).r);
    }
    // Blue Noise Sampler by Eric Heitz. Returns a value in the range [0, 1].
    float SampleRandomNumber(uint pixel_i, uint pixel_j, uint sample_index, uint sample_dimension) 
    {
        // Wrap arguments
        pixel_i = pixel_i & 127u;
        pixel_j = pixel_j & 127u;
        sample_index = sample_index & 255u;
        sample_dimension = sample_dimension & 255u;

        // xor index based on optimized ranking
        const uint ranked_sample_index = sample_index;

        // Fetch value in sequence
        uint value = GetSobolSample(uvec3(sample_dimension, ranked_sample_index * 256u, 0));
    

        // If the dimension is optimized, xor sequence value based on optimized scrambling
        uint originalIndex = (sample_dimension % 8u) + (pixel_i + pixel_j * 128u) * 8u;
        value = value ^ GetScramblingTile(uvec3(originalIndex % 512u, originalIndex / 512u, 0));

        // Convert to FfxFloat32 and return
        return (value + 0.5f) / 256.0f;
    }
    vec2 SampleRandomBlueNoiseVector2D(uvec2 pixel)
    {
        return texelFetch(u_BlueNoiseTexture, ivec2(pixel.xy % 128), 0).xy;
    }

#endif
#endif

