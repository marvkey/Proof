#ifndef COMMON_GLSL_H
#define COMMON_GLSL_H

const float PI = 3.1415926535897932384626433832795f;
const float TWO_PI = 2 * PI;
const float Epsilon = 0.00001;
layout(set = 3, binding = 0) uniform CameraData
{
  	mat4 Projection;
	mat4 InverseProjection;
	mat4 UnreversedProjectionMatrix;
	mat4 View;
	mat4 InverseView;
	mat4 ViewProjectionMatrix;// projection * view
	mat4 InverseViewProjectionMatrix;  //inversProjection * view

	vec3 Position;
	float NearPlane;
	float FarPlane;
}u_Camera;

layout (set = 3, binding = 1) uniform ScreenData
{
	vec2 FullResolution;
	vec2 InverseFullResolution;
	vec2 HalfResolution;
	vec2 InverseHalfResolution;
	float AspectRatio;
	float ResolutionScaling;
} u_ScreenData;

vec3 GetGradient(float value)
{
	vec3 zero = vec3(0.0, 0.0, 0.0);
	vec3 white = vec3(0.0, 0.1, 0.9);
	vec3 red = vec3(0.2, 0.9, 0.4);
	vec3 blue = vec3(0.8, 0.8, 0.3);
	vec3 green = vec3(0.9, 0.2, 0.3);

	float step0 = 0.0f;
	float step1 = 2.0f;
	float step2 = 4.0f;
	float step3 = 8.0f;
	float step4 = 16.0f;

	vec3 color = mix(zero, white, smoothstep(step0, step1, value));
	color = mix(color, white, smoothstep(step1, step2, value));
	color = mix(color, red, smoothstep(step1, step2, value));
	color = mix(color, blue, smoothstep(step2, step3, value));
	color = mix(color, green, smoothstep(step3, step4, value));

	return color;
}
float ConvertSRGBFromLinear(float value)
{
	return value <= 0.0031308f ? value * 12.92f : pow(value, 1.0f / 2.4f) * 1.055f - 0.055f;
}

vec3 RotateAroundYAxis(float angle, vec3 axis)
{
	float rad = radians(angle);
	mat3x3 rotationMatrix = {
		vec3(cos(rad), 0.0, sin(rad)),
		vec3(0.0, 1.0, 0.0),
		vec3(-sin(rad), 0.0, cos(rad))
	};
	
	return rotationMatrix * axis;
}
// Convert clip space coordinates to view space
vec4 ClipToView(vec4 clip)
{
    // View space position.
    vec4 view = u_Camera.InverseProjection * clip;
    // Perspective division.
    view /= view.w;

    return view;
}

// Convert screen space coordinates to view space.
vec4 ScreenToView(vec4 screen)
{
    // Convert to normalized texture coordinates
    vec2 texCoord = screen.xy / u_ScreenData.FullResolution;

    // Convert to clip space
    vec4 clip = vec4(vec2(texCoord.x, 1.0 - texCoord.y) * 2.0 - 1.0, screen.z, screen.w);

    return ClipToView(clip);
}

float LinearizeDepth(float z)
{
	return u_Camera.FarPlane / (u_Camera.FarPlane + z * (u_Camera.NearPlane - u_Camera.FarPlane));
}
vec3 GetViewPosition(vec2 texcoord, float depth)
{
	vec4 clipSpaceLocation;
	clipSpaceLocation.xy = texcoord * 2.0f - 1.0f;
	clipSpaceLocation.y *= -1;
	clipSpaceLocation.z = depth;
	clipSpaceLocation.w = 1.0f;
	vec4 homogenousLocation = clipSpaceLocation * u_Camera.InverseProjection;
	return homogenousLocation.xyz / homogenousLocation.w;
}
#endif // COMMON_GLSL_H