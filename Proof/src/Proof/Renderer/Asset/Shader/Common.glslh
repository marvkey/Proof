#ifndef COMMON_GLSL_H
#define COMMON_GLSL_H

const float PI = 3.1415926535897932384626433832795f;
const float TWO_PI = 2 * PI;
const float Epsilon = 0.00001;
layout(set = 3, binding = 0) uniform FrameData
{
	uint FrameCount;
	float AppTime;
}u_FrameData;
layout(set = 3, binding = 1) uniform CameraData
{
  	mat4 Projection;
	mat4 InverseProjection;
	mat4 UnreversedProjectionMatrix;
	mat4 View;
	mat4 InverseView;
	mat4 ViewProjectionMatrix;// projection * view
	mat4 InverseViewProjectionMatrix;  //inversProjection * view

	vec3 Position;
	float NearPlane;

	float FarPlane;
	float Fov;
	vec2 NDCToViewMul;

	vec2 NDCToViewAdd;
	vec2 DepthUnpackConsts;

	vec4 JitterData;	// Halton sequence jitter data, .xy is current frame jitter data, .zw is prev frame jitter data.

	uint JitterPeriod;        // jitter period for jitter data.
	bool bEnableJitter;       // Is main camera enable jitter in this frame.

} u_Camera;

layout (set = 3, binding = 2) uniform ScreenData
{
	vec2 FullResolution;
	vec2 InverseFullResolution;
	vec2 HalfResolution;
	vec2 InverseHalfResolution;
	float AspectRatio;
	float ResolutionScaling;
} u_ScreenData;

layout(set = 3, binding = 3) uniform sampler u_PointClampEdgeSampler;
layout(set = 3, binding = 4) uniform sampler u_PointClampBorder0000Sampler;
layout(set = 3, binding = 5) uniform sampler u_PointRepeatSampler;
layout(set = 3, binding = 6) uniform sampler u_PointClampBorder1111Sampler;

layout(set = 3, binding = 7) uniform sampler u_LinearClampEdgeSampler;
layout(set = 3, binding = 8) uniform sampler u_LinearClampBorder0000Sampler;
layout(set = 3, binding = 9) uniform sampler u_LinearRepeatSampler;
layout(set = 3, binding = 10) uniform sampler u_LinearClampBorder1111Sampler;

// With mip filter
layout(set = 3, binding = 11) uniform sampler u_LinearClampEdgeMipFilterSampler;
layout(set = 3, binding = 12) uniform sampler u_LinearRepeatMipFilterSampler;

float ConvertSRGBFromLinear(float value)
{
	return value <= 0.0031308f ? value * 12.92f : pow(value, 1.0f / 2.4f) * 1.055f - 0.055f;
}

vec3 RotateAroundYAxis(float angle, vec3 axis)
{
	float rad = radians(angle);
	mat3x3 rotationMatrix = {
		vec3(cos(rad), 0.0, sin(rad)),
		vec3(0.0, 1.0, 0.0),
		vec3(-sin(rad), 0.0, cos(rad))
	};
	
	return rotationMatrix * axis;
}
// Convert clip space coordinates to view space
vec4 ClipToView(vec4 clip)
{
    // View space position.
    vec4 view = u_Camera.InverseProjection * clip;
    // Perspective division.
     view = view / view.w;

    return view;
}

// Convert screen space coordinates to view space.
vec4 ScreenToView(vec4 screen)
{
    // Convert to normalized texture coordinates
    vec2 texCoord = screen.xy / u_ScreenData.FullResolution;

    // Convert to clip space
    vec4 clip = vec4(vec2(texCoord.x, 1.0 - texCoord.y) * 2.0 - 1.0, screen.z, screen.w);

    return ClipToView(clip);
}

//float LinearizeDepth(float z)
//{
//	return u_Camera.FarPlane / (u_Camera.FarPlane + z * (u_Camera.NearPlane - u_Camera.FarPlane));
//}
vec3 GetViewPosition(vec2 texcoord, float depth)
{
	vec4 clipSpaceLocation;
	clipSpaceLocation.xy = texcoord * 2.0f - 1.0f;
	clipSpaceLocation.y *= -1;
	clipSpaceLocation.z = depth;
	clipSpaceLocation.w = 1.0f;
	vec4 homogenousLocation = clipSpaceLocation * u_Camera.InverseProjection;
	return homogenousLocation.xyz / homogenousLocation.w;
}

float luminance(vec3 color)
{
    // human eye aware lumiance function.
    return dot(color, vec3(0.299, 0.587, 0.114));
}

// Quad schedule style, fake pixel shader dispatch style.
// Input-> [0, 63]
//
// Output:
//  00 01 08 09 10 11 18 19
//  02 03 0a 0b 12 13 1a 1b
//  04 05 0c 0d 14 15 1c 1d
//  06 07 0e 0f 16 17 1e 1f
//  20 21 28 29 30 31 38 39
//  22 23 2a 2b 32 33 3a 3b
//  24 25 2c 2d 34 35 3c 3d
//  26 27 2e 2f 36 37 3e 3f
uvec2 Remap8x8(uint lane) // gl_LocalInvocationIndex in 8x8 threadgroup.
{
    return uvec2(
        (((lane >> 2) & 0x0007) & 0xFFFE) | lane & 0x0001,
        ((lane >> 1) & 0x0003) | (((lane >> 3) & 0x0007) & 0xFFFC)
    );
}

// Build one TBN matrix from normal input.
// 
mat3 CreateTBN(vec3 N) 
{
    vec3 U;
    if (abs(N.z) > 0.0) 
    {
        float k = sqrt(N.y * N.y + N.z * N.z);
        U.x = 0.0; 
        U.y = -N.z / k; 
        U.z = N.y / k;
    }
    else 
    {
        float k = sqrt(N.x * N.x + N.y * N.y);
        U.x = N.y / k; 
        U.y = -N.x / k; 
        U.z = 0.0;
    }

    mat3 TBN = mat3(U, cross(N, U), N);
    return transpose(TBN);
}

#endif // COMMON_GLSL_H