//https://github.com/qiutang98/flower/blob/main/source/shader/sssr/sssr_common.glsl
#ifndef SSSR_COMMON_GLSL
#define SSSR_COMMON_GLSL
#extension GL_EXT_samplerless_texture_functions : enable

#include <Common.glslh>

#define BLUE_NOISE_BUFFER_BEGIN_BINDING 0
#include <Extras/BlueNoiseInclude.glslh>
struct DispatchIndirectCommand 
{
    uint x;
    uint y;
    uint z;
    uint pad;
};
layout(push_constant) uniform Info
{   
    uint SamplesPerQuad;
    uint TemporalVarianceGuidedTracingEnabled;
    uint MostDetailedMip;
    float RoughnessThreshold; // Max roughness stop to reflection sample.
    float TemporalVarianceThreshold;
} u_PushData;
bool IsGlossyReflection(float roughness) 
{
    return roughness < u_PushData.RoughnessThreshold;
}
// changable param 

const float kTemporalStableReprojectFactor = .8f; // big value is ghosting, small value is noise.
const int kTemporalPeriod = 32; // 32 is good for keep energy fill.
const float kTemporalStableFactor = kTemporalStableReprojectFactor;
const float kDepthBufferThickness = 0.015f;
const uint kMaxTraversalIterations = 64; // 128;
const uint kMinTraversalOccupancy = 4;

// FIX param.
const float kAverageRadianceLuminanceWeight = 0.3f;
const float kDisocclusionNormalWeight = 1.4f;
const float kDisocclusionDepthWeight = 1.0f;
const float kReprojectionNormalSimilarityThreshold = 0.9999;
const float kReprojectSurfaceDiscardVarianceWeight = 1.5;
const float kDisocclusionThreshold = 0.1;
const float kPrefilterNormalSigma = 512.0;
const float kPrefilterDepthSigma = 4.0;
const float kRadianceWeightBias = 0.6;
const float kRadianceWeightVarianceK = 0.1;
const float kPrefilterVarianceBias = 0.1;
const float kPrefilterVarianceWeight = 4.4;


layout (set  = 1, binding =7)  uniform sampler2D u_DepthMap;
layout (set  = 1, binding =8)  uniform sampler2D u_NormalMap;
layout (set  = 1, binding =9)  uniform textureCube  u_CubeMapPrefilter;
layout (set = 1, binding = 10) buffer SSSRRayCounterSSBO // has to be a storage because atomic cannot modify uniform 
{ 
    uint RayCount; 
    uint DenoiseTileCount;
} s_RayCounter; // SSR ray counter, use for intersection and denoise dispatch indirect args.

layout (set = 1, binding = 11) buffer SSSRRayListSSBO
{ 
    uint Data[]; 
} s_Raylist; // SSR ray list, use for ray list info cache.

layout (set = 1, binding = 12) buffer SSSRDenoiseTileListSSBO
{ 
    uint Data[]; 
} s_DenoiseTileList; // SSR denoise tile data, store some denoise info.

layout (set = 1, binding = 16) buffer SSSRIntersectCmdSSBO // have to maeke storage because we need to modify
{ 
    DispatchIndirectCommand args; 
} u_IntersectCommand;

layout (set = 1, binding = 17) buffer SSSRDenoiseCmdSSBO // have to maeke storage because we need to modify
{ 
    DispatchIndirectCommand args; 
} u_DenoiseCommand;



uint AddRayCount(uint value) 
{
    return atomicAdd(s_RayCounter.RayCount, value);
}

uint AddDenoiseTileCount()
{
    return atomicAdd(s_RayCounter.DenoiseTileCount, 1);
}


bool IsMirrorReflection(float roughness) 
{
    return roughness < 0.0001;
}

uint PackRayCoords(uvec2 rayCoord, bool bCopyHorizontal, bool bCopyVertical, bool bCopyDiagonal) 
{
    uint rayX15bit = rayCoord.x & 0x7FFF;
    uint rayY14bit = rayCoord.y & 0x3FFF;

    uint copyHorizontal1bit = bCopyHorizontal ? 1 : 0;
    uint copyVertical1bit   = bCopyVertical   ? 1 : 0;
    uint copyDiagonal1bit   = bCopyDiagonal   ? 1 : 0;

    uint packed = (copyDiagonal1bit << 31) | (copyVertical1bit << 30) | (copyHorizontal1bit << 29) | (rayY14bit << 15) | (rayX15bit << 0);
    return packed;
}

void UnpackRayCoords(uint packed, out uvec2 rayCoord, out bool bCopyHorizontal, out bool bCopyVertical, out bool bCopyDiagonal) 
{
    rayCoord.x = (packed >> 0) & 0x7FFF;
    rayCoord.y = (packed >> 15) & 0x3FFF;

    bCopyHorizontal = ((packed >> 29) & 0x1) != 0;
    bCopyVertical   = ((packed >> 30) & 0x1) != 0;
    bCopyDiagonal   = ((packed >> 31) & 0x1) != 0;
}

void AddRay(uint index, uvec2 rayCoord, bool bCopyHorizontal, bool bCopyVertical, bool bCopyDiagonal)
{
    s_Raylist.Data[index] = PackRayCoords(rayCoord, bCopyHorizontal, bCopyVertical, bCopyDiagonal);
}

void AddDenoiserTile(uint index, uvec2 tileCoord) 
{
    s_DenoiseTileList.Data[index] = ((tileCoord.y & 0xffffu) << 16) | ((tileCoord.x & 0xffffu) << 0);
}
// Construct position like view space or world space.
vec3 ConstructPos(vec2 uv, float depthZ, in const mat4 invertMatrix)
{
    vec4 posClip  = vec4(uv.x * 2.0f - 1.0f, 1.0f - uv.y * 2.0f, depthZ, 1.0f);
    vec4 posWorldRebuild = invertMatrix * posClip;
    return posWorldRebuild.xyz / posWorldRebuild.w;
}
// Construct world position from device z and it's sample uv.
vec3 GetWorldPos(vec2 uv, float depthZ)
{
    return ConstructPos(uv, depthZ, u_Camera.InverseViewProjectionMatrix);
}

vec3 EnvIBLReflectionCallback(uvec2 dispatchId, vec2 uv, float roughness)
{
    vec3 n = texelFetch(u_NormalMap, ivec2(dispatchId), 0).xyz; 
    float deviceZ = texelFetch(u_DepthMap, ivec2(dispatchId), 0).r;
    vec3 worldPos = GetWorldPos(uv, deviceZ);
    vec3 v = normalize(u_Camera.Position.xyz - worldPos);

    vec3 reflection = normalize(reflect(-v, n));
    float NdotV = clamp(dot(n, v), 0.0, 1.0);

    // Compute roughness's lod.
    uvec2 prefilterCubeSize = textureSize(u_CubeMapPrefilter, 0);
    float mipCount = float(log2(max(prefilterCubeSize.x, prefilterCubeSize.y)));
    float lod = clamp(roughness * float(mipCount), 0.0, float(mipCount));
    
    // Load environment's color from prefilter color.
    vec3 specularLight = textureLod(samplerCube(u_CubeMapPrefilter, u_LinearClampEdgeSampler), reflection, lod).rgb;
    return specularLight;
}

const int   kLocalNeighborhoodRadius = 4;
const float kGaussianK = 3.0;

float LocalNeighborhoodKernelWeight(float i) 
{
    const float radius = kLocalNeighborhoodRadius + 1.0;
    return exp(-kGaussianK * (i * i) / (radius * radius));
}

float LuminanceSSR(vec3 color) 
{ 
    return float(max(luminance(color), 0.001)); 
}

float ComputeTemporalVariance(vec3 radiance, vec3 historyRadiance) 
{
    float historyLuminance = LuminanceSSR(historyRadiance);
    float luminanceCurrent = LuminanceSSR(radiance);

    float diff  = abs(historyLuminance - luminanceCurrent) / max(max(historyLuminance, luminanceCurrent), 0.5);
    return diff * diff;
}

vec3 GetIBLContribution(float perceptualRoughness, vec3 n, vec3 v)
{
    vec3 reflection = normalize(reflect(-v, n));
    float NdotV = clamp(dot(n, v), 0.0, 1.0);

    // Compute roughness's lod.
    uvec2 prefilterCubeSize = textureSize(u_CubeMapPrefilter, 0);
    float mipCount = float(log2(max(prefilterCubeSize.x, prefilterCubeSize.y)));
    float lod = clamp(perceptualRoughness * float(mipCount), 0.0, float(mipCount));
    
    return textureLod(samplerCube(u_CubeMapPrefilter, u_LinearClampEdgeSampler), reflection, lod).rgb;
}
vec3 SampleEnvironmentMap(vec3 direction, float roughness)
{
    ivec2 cubeSize = textureSize(u_CubeMapPrefilter, 0);
    int maxMipLevel = int(log2(float(cubeSize.x > 0 ? cubeSize.y : 1)));
    float lod = clamp(roughness * float(maxMipLevel), 0.0, float(maxMipLevel));
    //return textureLod(samplerCube(u_CubeMapPrefilter, u_LinearClampEdgeSampler), direction, lod).xyz * IBLFactor();
    return textureLod(samplerCube(u_CubeMapPrefilter, u_LinearClampEdgeSampler), direction, lod).xyz;
}

vec3 LoadWorldSpaceNormal(ivec2 coords)
{
    //https://github.com/GPUOpen-LibrariesAndSDKs/FidelityFX-SDK/blob/d7531ae47d8b36a5d4025663e731a47a38be882f/samples/cacao/cacaorendermodule.cpp#L160
    // nomrals unpack mull
    const float normalUnpackMul =2;
    const float normalUnpackAdd =-1;
    return normalize(normalUnpackMul * texelFetch(u_NormalMap, coords, 0).xyz + normalUnpackAdd);
}

vec3 InvProjectPosition(vec3 coord, mat4 mat) 
{
    coord.y = (1 - coord.y);
    coord.xy = 2 * coord.xy - 1;
    vec4 projected = mat * vec4(coord, 1);
    projected.xyz /= projected.w;
    return projected.xyz;
}
vec3 ScreenSpaceToViewSpace(vec3 screen_space_position) {
    return InvProjectPosition(screen_space_position, u_Camera.InverseProjection);
}

vec3 ScreenSpaceToWorldSpace(vec3 screen_space_position) {
    return InvProjectPosition(screen_space_position, u_Camera.InverseView);
}
#endif