#ifndef LIGHT_CULLING_FUNCTIONS
#define LIGHT_CULLING_FUNCTIONS
#define TILE_SIZE 16 
#define MAX_LIGHT_COUNT 1024
//https://www.3dgep.com/forward-plus/#Forward

struct Plane
{
	vec3 Normal;
	float Distance;// distance to origin
};

// Compute a plane from 3 noncollinear points that form a triangle.
// This equation assumes a right-handed (counter-clockwise winding order) 
// coordinate system to determine the direction of the plane normal.
Plane ComputePlane( vec3 p0, vec3 p1, vec3 p2 )
{
    Plane plane;

    vec3 v0 = p1 - p0;
    vec3 v2 = p2 - p0;

    plane.Normal = normalize( cross( v0, v2 ) );

    // Compute the distance to the origin using p0.
    plane.Distance = dot( plane.Normal, p0 );

    return plane;

}

// Four planes of a view frustum (in view space).
// The planes are:
//  * Left,
//  * Right,
//  * Top,
//  * Bottom.
// The back and/or front planes can be computed from depth values in the 
// light culling compute shader.
struct Frustum
{
    Plane planes[4];   // left, right, top, bottom frustum planes.
};

struct Sphere
{
    vec3 Center;   // Center point.
    float Radius;   // Radius.
};

// Check to see if a sphere is fully behind (inside the negative halfspace of) a plane.
// Source: Real-time collision detection, Christer Ericson (2005)
bool SphereInsidePlane( Sphere sphere, Plane plane )
{
    return dot( plane.Normal, sphere.Center ) - plane.Distance < -sphere.Radius;
}

// Check to see of a light is partially contained within the frustum.
bool SphereInsideFrustum( Sphere sphere, Frustum frustum, float zNear, float zFar )

{
    bool result = true;

    // First check depth
    // Note: Here, the view vector points in the -Z axis so the 
    // far depth value will be approaching -infinity.
    if ( sphere.Center.z - sphere.Radius > zNear || sphere.Center.z + sphere.Radius < zFar )
    {
        result = false;
    }

    // Then check frustum planes
    for ( int i = 0; i < 4 && result; i++ )
    {
        if ( SphereInsidePlane( sphere, frustum.planes[i] ) )
        {
            result = false;
        }
    }
    return result;
}

struct Cone
{
    vec3 Tip;   // Cone tip.
    float  Height;   // Height of the cone.
    vec3 Direction;   // Direction of the cone.
    float  Radius;   // bottom radius of the cone.

    
};
bool PointInsidePlane( vec3 p, Plane plane )
{
/*
        To test if a cone is completely contained in the negative half-space of a plane, only two points need to be tested.

        The tip T
         of the cone
        The point Q
         that is on the base of the cone that is farthest away from the plane in the direction of n
        If both of these points are contained in the negative half-space of any of the frustum planes, then the cone can be culled.

        To determine the point Q
         that is farthest away from the plane in the direction of n
         we will compute an intermediate vector m
         which is parallel but opposite to n
         and perpendicular to d
        .

        m=(n×d)×d
        Q
         is obtained by stepping from the tip T
         along the cone axis d
         at a distance h
         and then along the base of the cone away from the positive half-space of the plane −m
         at a factor of r
        .

        Q=T+hd−rm
        If n×d
         is zero, then the cone axis d
         is parallel to the plane normal n
         and m
         will be a zero vector. This special case does not need to be handled specifically because in this case the equation reduces to:

        Q=T+hd
        Which results in the correct point that needs to be tested.

        With points T
         and Q
         computed, we can test both points if they are in the negative half-space of the plane. If they are, we can conclude that the light can be culled. To test if a point is in the negative half-space of the plane, we can use the following equation:

        l=(n⋅X)−d
        Where l
         is the signed distance from the point to the plane and X
         is the point to be tested. If l
         is negative, then the point is contained in the negative half-space of the plane.
*/

    return dot( plane.Normal, p ) - plane.Distance < 0;
}

// Check to see if a cone if fully behind (inside the negative halfspace of) a plane.
// Source: Real-time collision detection, Christer Ericson (2005)

bool ConeInsidePlane( Cone cone, Plane plane )
{


    // Compute the farthest point on the end of the cone to the positive space of the plane.
    vec3 m = cross( cross( plane.Normal, cone.Direction ), cone.Direction );
    vec3 Q = cone.Tip + cone.Direction * cone.Height - m * cone.Radius;

    // The cone is in the negative halfspace of the plane if both
    // the tip of the cone and the farthest point on the end of the cone to the 
    // positive halfspace of the plane are both inside the negative halfspace 
    // of the plane.
    return PointInsidePlane( cone.Tip, plane ) && PointInsidePlane( Q, plane );

}
bool ConeInsideFrustum( Cone cone, Frustum frustum, float zNear, float zFar )
{
    bool result = true;
    Plane nearPlane = { vec3( 0, 0, -1 ), -zNear };
    Plane farPlane = { vec3( 0, 0, 1 ), zFar };
    // First check the near and far clipping planes.
    if ( ConeInsidePlane( cone, nearPlane ) || ConeInsidePlane( cone, farPlane ) )
    {
        result = false;
    }
    // Then check frustum planes
    for ( int i = 0; i < 4 && result; i++ )
    {
        if ( ConeInsidePlane( cone, frustum.planes[i] ) )
        {
            result = false;
        }
    }
    return result;
}

#endif //LIGHT_CULLING_FUNCTIONS